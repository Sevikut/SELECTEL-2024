#pragma config(Sensor, S1,     ,               sensorEV3_Touch)
#pragma config(Sensor, S2,     ,               sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S3,     ,               sensorEV3_Color, modeEV3Color_Color)
#pragma config(Motor,  motorC,           ,             tmotorEV3_Large, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// oz 					-510
// first floor 	0
// second floor -400
// third floor 	-780
//number = 3;
//int number = 0;
int point = 0;
byte mass[3][3] = {0,0,0, 0,0,0, 0,0,0};
byte colorCode[4] = {0,0,0,0};

void vudvizh(bool flag)
{
	int oZ;
	if(flag)
		oZ = -510;
	else
		oZ = -5;

	while(abs(nMotorEncoder[motorD] - oZ) > 3)
	{
		if(nMotorEncoder[motorD] - oZ < 0)
			motor[motorD] = 20;
		else if(nMotorEncoder[motorD] - oZ > 0)
			motor[motorD] = -20;
		else
			motor[motorD] = 0;
	}
}

void position(int oX, int oY)
{
	while(abs(nMotorEncoder[motorA] - oX) > 5 || abs(nMotorEncoder[motorB] - oY) > 3)
	{
		if(nMotorEncoder[motorA] - oX < 0)
			motor[motorA] = 20;
		else if(nMotorEncoder[motorA] - oX > 0)
			motor[motorA] = -20;
		else
			motor[motorA] = 0;

		if(nMotorEncoder[motorB] - oY < 0)
			motor[motorB] = 20;
		else if(nMotorEncoder[motorB] - oY > 0)
			motor[motorB] = -20;
		else
			motor[motorB] = 0;
	}
	motor[motorA] = 0;
	motor[motorB] = 0;
	wait1Msec(20);
}

void zahvat(bool flag)
{
	if (flag)
	{
		clearTimer(timer1);
		while(nMotorEncoder[motorC] < 0 && time1[timer1] < 3000)
		{
			motor[motorC] = 40;
		}
		motor[motorC] = 0;
		wait1Msec(20);
	}
	else
	{
		while(nMotorEncoder[motorC] > -1100)
		{
			motor[motorC] = -20;
		}
		motor[motorC] = 0;
		wait1Msec(20);
	}

}

void capture() //zahvat posulki
{
	vudvizh(true);

	int a = nMotorEncoder[motorA];
	int b = nMotorEncoder[motorB];

	position(a , b + 40);

	zahvat(true);

	position(a , b - 40);

	vudvizh(false);

}

void nCapture() //zahvat posulki
{
	int a = nMotorEncoder[motorA];
	int b = nMotorEncoder[motorB];

	position(a , b - 40);
	vudvizh(true);
	position(a , b + 40);
	zahvat(false);
	position(a , b - 40);
	vudvizh(false);

}

void home()
{
	vudvizh(false);
	position (-40 , - 40);
	while (SensorValue[S1] == 0) motor[motorA] = -20;
	delay(300);
	nMotorEncoder[motorA] = 0;
	position (-7 , - 40);
}

void all()
{
	switch(point)
	{
	case 11:
		position(910, -40);
		break;

	case 12:
		position(1460, -40);
		break;

	case 13:
		position(1995, -40);
		break;

	case 21:
		position(910, -410);
		break;

	case 22:
		position(1460, -410);
		break;

	case 23:
		position(1995, -410);
		break;

	case 31:
		position(910, -790);
		break;

	case 32:
		position(1460, -790);
		break;

	case 33:
		position(1995, - 790);
		break;
	default:
		position(-7, - 40);
		playSound(soundBeepBeep);
		delay(100);
		break;
	}

}

void calibr()
{
	//oz
	clearTimer(timer1);
	while (time1[timer1] < 15000)
	{
		if(time1[timer1] < 300)
			motor[motorD] = -20;
		else if (time1[timer1] < 5000)
			motor[motorD] = 20;
		else
			motor[motorD] = 0;


		//zaxvat
		if(time1[timer1] < 300)
			motor[motorC] = -20;
		else if(time1[timer1] < 7000)
			motor[motorC] = 20;
		else
			motor[motorC] = 0;

		//oy
		if(time1[timer1] < 300)
			motor[motorB] = -20;
		else if(time1[timer1] < 4000)
			motor[motorB] = 0;
		else if (time1[timer1] < 12000)
			motor[motorB] = 20;
		else
			motor[motorB] = 0;


		//ox
		if(time1[timer1] < 300)
			motor[motorA] = 40;
		else if(time1[timer1] < 4000)
			motor[motorA] = 0;
		else if (SensorValue[S1] == 0)
		{
			motor[motorA] = -30;
		}
		else
		{
			motor[motorA] = 0;
		}
	}

	nMotorEncoder[motorA] = 0;
	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;
	nMotorEncoder[motorD] = 0;
	delay(1000);
	zahvat(false);
	playSound(soundBlip);
}

int colorDetect(int sensor)
{
	int red, blue, green;
	int col = 0;

	getColorRGB(sensor, red, green, blue);
	if (red / (blue + green + 1) > 1.6) col = 1;
	else if ((blue + green +1) / (red + 1) > 6) col = 2;
	else if (green / (red + blue + 1) > 0.7) col = 3;
	else if ((green + red) / (blue + 1) > 10 && red / (blue + green + 1) < 3)  col = 4;
	else if ((green + red) / (blue + 1) > 4 && red / (blue + green + 1) < 3)  col = 5;
	else if (green + red + blue < 5) col = 0;
	else col = 0;

	/*displayCenteredBigTextLine( 1 , "r: %d" , red);
	displayCenteredBigTextLine( 3 , "g: %d" , green);
	displayCenteredBigTextLine( 5 , "b: %d" , blue);*/

	return col;
}

void vzjat()
{
	all();
	capture();
	home();
	nCapture();
}
void polozhit()
{
	capture();
	all();
	nCapture();
	home();
}

task main()
{
	calibr();
	position (-10 , - 40);

	while(true)
	{
		point = 0;
	tryagain:

		if((colorDetect(S2) == 0) || (colorDetect(S3) == 0))
		{
			displayCenteredBigTextLine( 7 , "codeNoDetected");
			delay(1000);
			goto tryagain;
		}

		for(int i = 0; i < 4;  i++)
		{
			colorCode[i] = colorDetect(S2)*10 + colorDetect(S3);
			delay(5);
		}

		if(colorCode[0] == colorCode[1] && colorCode[1] == colorCode[2] && colorCode[2] == colorCode[3])
			displayCenteredBigTextLine( 11 , "colorCode: %d" , colorCode[0]);
		else goto tryagain;

		switch(colorCode[0])
		{
		case 21: colorCode[0] = 12; break;
		case 31: colorCode[0] = 13; break;
		case 41: colorCode[0] = 14; break;
		case 51: colorCode[0] = 15; break;
		case 32: colorCode[0] = 23; break;
		case 42: colorCode[0] = 24; break;
		case 52: colorCode[0] = 25; break;
		case 43: colorCode[0] = 34; break;
		case 53: colorCode[0] = 35; break;
		default: break;
		}

		for(int j = 0; j < 3; j++)
		{
			for(int i = 0; i < 3; i++)
			{
				if (mass[i][j] == colorCode[0])
				{
					point = (i+1) * 10 + (j+1);
					mass[i][j] = 0;
					displayCenteredBigTextLine( 3 , "parcel found");
					displayCenteredBigTextLine( 5 , "in box: %d-%d", i+1, j+1);
					vzjat();
					goto tryagain;
				}
			}
		}
		for(int j = 0; j < 3; j++)
		{
			for(int i = 0; i < 3; i++)
			{
				if (mass[i][j] == 0)
				{
					point = (i+1) * 10 + (j+1);
					mass[i][j] = colorCode[0];
					displayCenteredBigTextLine( 3 , "parcel put");
					displayCenteredBigTextLine( 5 , "in box: %d-%d", i+1, j+1);
					polozhit();
					goto tryagain;
				}
			}
		}
	}
}
